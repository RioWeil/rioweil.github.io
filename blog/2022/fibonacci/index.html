<!DOCTYPE html> <html lang="en"> <head> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title>Four ways to Fibonacci | Ryohei (Rio) Weil</title> <meta name="author" content="Ryohei (Rio) Weil"/> <meta name="description" content="Finding the Fibonacci numbers through algorithms, linear algebra, and generating functions."/> <meta name="keywords" content="jekyll, jekyll-theme, academic-website, portfolio-website"/> <link href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha256-DF7Zhf293AJxJNTmh5zhoYYIMs2oXitRfBjY+9L//AY=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"/> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/academicons@1.9.1/css/academicons.min.css" integrity="sha256-i1+4qU2G2860dGGIOJscdC30s9beBXjFfzjWLjBRsBg=" crossorigin="anonymous"> <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jwarby/jekyll-pygments-themes@master/github.css" media="none" id="highlight_theme_light"/> <link rel="shortcut icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>⚛️</text></svg>"> <link rel="stylesheet" href="/assets/css/main.css"> <link rel="canonical" href="https://rioweil.github.io/blog/2022/fibonacci/"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jwarby/jekyll-pygments-themes@master/native.css" media="none" id="highlight_theme_dark"/> <script src="/assets/js/theme.js"></script> <script src="/assets/js/dark_mode.js"></script> </head> <body class="fixed-top-nav "> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="https://rioweil.github.io/"><span class="font-weight-bold">Ryohei (Rio)</span> Weil</a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">About</a> </li> <li class="nav-item "> <a class="nav-link" href="/publications/">Publications</a> </li> <li class="nav-item "> <a class="nav-link" href="/talks/">Talks</a> </li> <li class="nav-item dropdown "> <a class="nav-link dropdown-toggle" href="#" id="navbarDropdown" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">Projects</a> <div class="dropdown-menu dropdown-menu-right" aria-labelledby="navbarDropdown"> <a class="dropdown-item" href="/notes/">Lecture Notes</a> <div class="dropdown-divider"></div> <a class="dropdown-item" href="/solutions/">Textbook Solutions</a> <div class="dropdown-divider"></div> <a class="dropdown-item" href="/music/">Music</a> <div class="dropdown-divider"></div> <a class="dropdown-item" href="/courseprojects/">Course Projects</a> <div class="dropdown-divider"></div> <a class="dropdown-item" href="/misc/">Miscellaneous</a> </div> </li> <li class="nav-item active"> <a class="nav-link" href="/blog/">Blog<span class="sr-only">(current)</span></a> </li> <div class="toggle-container"> <a id="light-toggle"> <i class="fas fa-moon"></i> <i class="fas fa-sun"></i> </a> </div> </ul> </div> </div> </nav> </header> <div class="container mt-5"> <div class="post"> <header class="post-header"> <h1 class="post-title">Four ways to Fibonacci</h1> <p class="post-meta">June 2, 2022</p> <p class="post-tags"> <a href="/blog/2022"> <i class="fas fa-calendar fa-sm"></i> 2022 </a>   ·   <a href="/blog/category/math"> <i class="fas fa-tag fa-sm"></i> math</a>   </p> </header> <article class="post-content"> <p><strong>June 2, 2022.</strong> <em>The Fibonacci numbers arise frequently (and often unexpectedly) in mathematics and in biological systems. In this post, we discuss four ways of calculating them: through brute force, through brute force (but in a more clever fashion), through linear algebra, and finally through the use of generating functions.</em></p> <p>The Fibonacci numbers are a sequence of integers defined recursively by \(f_0 = 0, f_1 = 1\), and</p> <p>\begin{equation}\label{eq:fibonacci} f_n = f_{n-1} + f_{n-2} \end{equation}</p> <p>for \(n &gt; 1\). If one has a computer on hand, this immediately invites a brute force recursive solution.</p> <h3 id="method-1-brute-force-computation">Method 1: Brute force computation</h3> <p>Translating the definition of the Fibonacci numbers in Eq. \eqref{eq:fibonacci} directly into code (in this case, Python), we end up with:</p> <figure class="highlight"><pre><code class="language-python" data-lang="python"><table class="rouge-table"><tbody><tr>
<td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre></td> <td class="code"><pre><span class="k">def</span> <span class="nf">fibonacci</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">0</span>
    <span class="k">elif</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">1</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="nf">fibonacci</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="nf">fibonacci</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span>
</pre></td> </tr></tbody></table></code></pre></figure> <p>This solution is conceptually pretty as it makes evident use of the recursive structure of the numbers, but in practice performs very poorly. For one, Python has a recursion limit of 1000 by default and we should probably use a functional programming language (such as Haskell) instead which is better suited for handling recursion. However even beyond this technical limitation, as the input \(n\) grows large the above method slows down considerably. Let us calculate how many operations are required to calculate the \(n\)th fibonacci number with the above algorithm. Let us make the ansatz that the the number of addition operations \(A(n)\) required to produce the \(n\)th fibonacci number is \(A(n) = x^n\) (for some \(x &gt; 1\)). By the defining recursive formula of Eq. \eqref{eq:fibonacci}, we have (for \(n &gt; 1\)) that:</p> \[A(n) = A(n - 1) + A(n - 2) + 1\] <p>and so with our ansatz this becomes:</p> \[x^n = x^{n-1} + x^{n-2} + 1.\] <p>Dividing out by \(x^{n-2}\) and rearranging, we find:</p> \[x^2 - x - 1 - x^{2 - n} = 0.\] <p>Since we are interested in the asymptotic (large \(n\)) number of additions required to calculate \(f_n\), we have in this limit that \(x^{2 - n} \to 0\) and hence:</p> \[x^2 - x - 1 \approx 0.\] <p>Applying the quadratic formula to solve for \(x\), we find:</p> \[x \approx \frac{1 \pm \sqrt{5}}{2}\] <p>and taking the positive solution, we find that \(x\) is precisely the golden ratio:</p> \[\varphi = \frac{1 + \sqrt{5}}{2}\] <p>and so we conclude:</p> \[A(n) \approx \varphi^n = \left(\frac{1 + \sqrt{5}}{2}\right)^n.\] <p>We will see very shortly that the golden ratio will come up when we solve for a closed-form expression for \(f_n\). Before we try to find this, let us see if we can improve the above brute force algorithm (as the exponential time complexity we find above is quite terrible in practice). The inefficiency comes from the fact that we do a lot of redundant computations between the two branches of the recursive calls to <code class="language-plaintext highlighter-rouge">fibonacci(n)</code>. If we had some way to “remember” the computations we have already done, we could avoid this redundancy. To this end, we introduce memoization, where we store the results of past calls to the function and return them when they are again requested (instead of computing them all over again).</p> <h3 id="method-2-brute-force-computation-with-memoization">Method 2: Brute force computation (with memoization)</h3> <p>Our improved algorithm takes the form:</p> <figure class="highlight"><pre><code class="language-python" data-lang="python"><table class="rouge-table"><tbody><tr>
<td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre></td> <td class="code"><pre><span class="n">fib_dict</span> <span class="o">=</span> <span class="p">{}</span>
<span class="n">fib_dict</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">fib_dict</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="k">def</span> <span class="nf">fibonacci_mem</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">n</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">fib_dict</span><span class="p">:</span>
        <span class="n">fib_dict</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="nf">fibonacci_mem</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="nf">fibonacci_mem</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">fib_dict</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>   
</pre></td> </tr></tbody></table></code></pre></figure> <p>where we have defined a dictionary <code class="language-plaintext highlighter-rouge">fib_dict</code> that stores computed fibonacci numbers so we don’t have to compute them all over again. Since checking if a key is in a dictionary and dictionary lookup are both \(O(1)\) on average, this memoized algorithm is actually linear in time complexity, instead of exponential.</p> <p>Let us verify this claim that \(T(n) = O(n)\) where \(T(n)\) is the time complexity of calculating the \(n\)th Fibonacci number with the above improved algorithm. First, we have that \(T(0) = T(1) = O(1)\). For \(n &gt; 1\), the time complexity \(T(n)\) is equal (from Eq. \eqref{eq:fibonacci}) to the time complexity of calculating \(f_{n-1}\) plus the time complexity of calculating \(f_{n-2}\) plus an \(O(1)\) addition operation of adding them together. Computing \(f_{n-1}\) will be a \(T(n-1)\) operation, but since the computation of \(f_{n-2}\) will already be done (and recorded) in the computation of \(f_{n-1}\), this will just be an \(O(1)\) dictionary lookup. Hence:</p> \[T(n) = T(n - 1) + O(1) + O(1) = T(n - 1) + O(1)\] <p>Now recursively applying this formula \(n-1\) times, we find:</p> \[T(n) = T(n - (n-1)) + (n-1)O(1) = T(1) + (n-1)O(1) = O(1) + (n-1)O(1) = O(n)\] <p>which proves the claim. Memoization is in general improvement for problems with recursive structure. Having explored the problem fairly thoroughly algorithmically, let us see if we can find insights through mathematical derivation.</p> <h3 id="method-3-linear-algebra-and-diagonalization">Method 3: Linear algebra and diagonalization</h3> <p>In this next approach, we will use some techniques from linear algebra to obtain a closed form expression for the Fibonacci numbers. To start, we make the observation that we can write the recursion relation of Eq. \eqref{eq:fibonacci} as a matrix equation:</p> \[\begin{bmatrix} f_{n} \\ f_{n-1} \end{bmatrix} = A\begin{bmatrix} f_{n-1} \\ f_{n-2} \end{bmatrix}\] <p>where:</p> \[A = \begin{bmatrix} 1 &amp; 1 \\ 1 &amp; 0 \end{bmatrix}.\] <p>By recursive application of this formula, we can write the LHS in terms of \(f_1 = 1\) and \(f_0 = 0\):</p> \[\begin{bmatrix} f_{n} \\ f_{n-1} \end{bmatrix} = A^{n-1}\begin{bmatrix} f_{1} \\ f_{0} \end{bmatrix} =A^{n-1} \begin{bmatrix} 1 \\ 0 \end{bmatrix}.\] <p>If we can obtain a closed form expression for \(A^{n-1}\), we can easily evaluate the left hand side of the above equation to find \(f_n\). To do this, we diagonalize \(A\). Solving for the eigenvalues of \(A\), we have:</p> \[\det(A - \lambda I) = \det \begin{bmatrix} 1 - \lambda &amp; 1 \\ 1 &amp; -\lambda \end{bmatrix} = (1-\lambda)(-\lambda) - 1 = \lambda^2 - \lambda - 1.\] <p>Applying the quadratic formula, we find that \(\lambda_1 = \frac{1 + \sqrt{5}}{2}\), \(\lambda_2 = \frac{1 - \sqrt{5}}{2}\). Note that the golden ratio again emerges here, and we may write \(\lambda_1 = \varphi\), \(\lambda_2 = 1 - \varphi\). Solving for the corresponding eigenvectors, we have:</p> \[(A - \lambda_1 I)\mathbf{v}_1 = \mathbf{0} \implies \begin{bmatrix} 1 - \varphi &amp; 1 \\ 1 &amp; -\varphi\end{bmatrix}\mathbf{v}_1 = \mathbf{0} \implies \mathbf{v}_1 = \begin{bmatrix} \varphi \\ 1 \end{bmatrix}\] \[(A - \lambda_2 I)\mathbf{v}_2 = \mathbf{0} \implies \begin{bmatrix} \varphi &amp; 1 \\ 1 &amp; \varphi - 1 \end{bmatrix}\mathbf{v}_2 = \mathbf{0} \implies \mathbf{v}_2 = \begin{bmatrix} 1 - \varphi \\ 1 \end{bmatrix}\] <p>If we then let:</p> \[D = \begin{bmatrix} \lambda_1 &amp; 0 \\ 0 &amp; \lambda_2 \end{bmatrix} = \begin{bmatrix} \varphi &amp; 0 \\ 0 &amp; 1-\varphi \end{bmatrix}\] \[V = \begin{bmatrix} \mathbf{v}_1 &amp; \mathbf{v}_2 \end{bmatrix} = \begin{bmatrix} \varphi &amp; 1-\varphi \\ 1 &amp; 1 \end{bmatrix}\] <p>we can diagonalize \(A\) as:</p> \[A = VDV^{-1}\] <p>where \(V^{-1}\) is obtained by inverting \(V\):</p> \[V^{-1} = \frac{1}{\varphi \cdot 1 - (1 - \varphi) \cdot 1}\begin{bmatrix} 1 &amp; -(1-\varphi) \\ -1 &amp; \varphi\end{bmatrix} = \frac{1}{2\varphi - 1}\begin{bmatrix}1 &amp; -(1-\varphi) \\ -1 &amp; \varphi\end{bmatrix}.\] <p>Powers of \(A\) can be easily obtained in this form:</p> \[A^{n-1} = (VDV^{-1})(VDV^{-1})\ldots(VDV^{-1}) = VD^{n-1}V^{-1}\] <p>where</p> \[D^{n-1} = \begin{bmatrix} \lambda_1^{n-1} &amp; 0 \\ 0 &amp; \lambda_2^{n-1} \end{bmatrix} = \begin{bmatrix} (\varphi)^{n-1} &amp; 0 \\ 0 &amp; (1-\varphi)^{n-1} \end{bmatrix}.\] <p>Therefore by matrix-vector multiplication we have:</p> \[\begin{bmatrix} f_{n} \\ f_{n-1} \end{bmatrix} = VD^{n-1}V^{-1}\begin{bmatrix} 1 \\ 0 \end{bmatrix} = \frac{1}{2\varphi - 1}\begin{bmatrix}\varphi^n - (1-\varphi)^n \\ \varphi^{n-1} - (1-\varphi)^{n-1} \end{bmatrix}\] <p>from which we conclude the closed form solution of \(f_n\) to be:</p> \[f_n = \frac{\varphi^n - (1-\varphi)^n}{2\varphi - 1}.\] <p>In the limit of large \(n\), since \(1 - \varphi &lt; 0\) we have \((1 - \varphi)^n \to 0\). In this limit we therefore have:</p> \[f_n \approx \frac{\varphi^n}{2\varphi - 1}.\] <p>A notable observation is that the <em>value</em> of \(f_n\) has the same asymptotic growth as the time complexity/number of operations required to calculate it per the brute force algorithmic approach!</p> <h3 id="method-4-generating-functions">Method 4: Generating functions</h3> <p>For a final approach, we introduce the notion of a generating function, where an infinite sequence of numbers is encoded in the coefficients of a power series. A common application of generating functions is in probability theory, where moment generating functions of a random variable \(X\), defined as:</p> \[M_X(s) = \mathbf{E}(e^{sX})\] <p>(with \(\mathbf{E}\) denoting expectation) encodes the moments of the distribution of \(X\), with:</p> \[\mathbf{E}(X^k) = \left. \frac{\mathrm{d}}{\mathrm{d}s} M_X(s) \right|_{s = 0}.\] <p>Another application is in statistical mechanics, where the derivatives of the logarithm of a system’s partition function encodes the mean energy (and other related quantities) of the system. Surprisingly, this tool comes in useful for combinatorics problems, such as solving for the Fibonacci numbers! To this end, we define a power series \(F(x)\) such that the coefficients are the Fibonacci numbers:</p> \[F(x) = \sum_{n=0}^\infty f_n x^n.\] <p>We can then apply the recursion relation Eq. \eqref{eq:fibonacci} termwise to obtain the expression:</p> \[\sum_{n=0}^\infty f_n x^n = \sum_{n=0}^\infty f_{n-1}x^n + \sum_{n=0}^\infty f_{n-2}x^{n} + x\] <p>where we let \(f_{-2} = f_{-1} = 0\), and the extra \(x\) on the right hand side is present to enforce \(f_1 = 1\). Factoring some powers of \(x\), we find:</p> \[\sum_{n=0}^\infty f_n x^n = x\sum_{n=0}^\infty f_{n-1}x^{n-1} + x^2\sum_{n=0}^\infty f_{n-2}x^{n-2} + x\] <p>and re-indexing the series on the left hand side and applying the definition of the Fibonacci generating function, we find:</p> \[F(x) = xF(x) + x^2F(x) + x.\] <p>We may then isolate \(F(x)\) to obtain:</p> \[F(x) = \frac{x}{1 - x - x^2} = \frac{-x}{x^2 + x - 1}\] <p>\(x^2 + x - 1\) has the two roots \(x = \frac{-1 \pm \sqrt{5}}{2}\), or in terms of the golden ratio, \(x = \varphi - 1\) and \(x = -\varphi\). We may then write:</p> \[F(x) = \frac{-x}{(x - (\varphi - 1))(x + \varphi)}.\] <p>By partial fraction decomposition, we have:</p> \[F(x) = \frac{-\frac{\varphi - 1}{2\varphi - 1}}{x - (\varphi - 1)} + \frac{-\frac{\varphi}{2\varphi - 1}}{x + \varphi} = \frac{-1}{2\varphi - 1}\left(\frac{1}{\frac{x}{\varphi - 1} - 1} + \frac{1}{\frac{x}{\varphi} + 1}\right).\] <p>Using the identity \(\varphi - 1 = \frac{1}{\varphi}\), we may rewrite this as:</p> \[F(x) = \frac{-1}{2\varphi - 1}\left(\frac{1}{\varphi x - 1} + \frac{1}{(\varphi - 1)x + 1}\right) = \frac{1}{2\varphi - 1}\left(\frac{1}{1 - \varphi x} - \frac{1}{1 - (1 - \varphi)x}\right).\] <p>Now using the geometric series formula for both terms:</p> \[F(x) = \frac{1}{2\varphi - 1}\left(\sum_{n=0}^\infty (\varphi x)^n - \sum_{n=0}^\infty ((1-\varphi)x)^n \right) = \sum_{n=0}^\infty \frac{\varphi^n - (1-\varphi)^n}{2\varphi - 1} x^n.\] <p>Since the coefficients of \(F(x)\) are the Fibonacci numbers by definition, we conclude that:</p> \[f_n = \frac{\varphi^n - (1-\varphi)^n}{2\varphi - 1}\] <p>which we can see agrees with our previous result from the linear algebra approach.</p> <h3 id="acknowledgements">Acknowledgements</h3> <p>Thank you to Yaniv Plan/Richard Anstee for presenting the clever diagonalization approach in MATH 223 (Honours Linear Algebra), and to 3Blue1Brown for his <a href="https://www.youtube.com/watch?v=bOXCLR3Wric" target="_blank" rel="noopener noreferrer">fantastic video</a> on using generating functions to solve problems in combinatorics.</p> </article> </div> </div> <footer class="fixed-bottom"> <div class="container mt-0"> © Copyright 2025 Ryohei (Rio) Weil. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="noopener noreferrer">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" target="_blank" rel="noopener noreferrer">al-folio</a> theme. Hosted by <a href="https://pages.github.com/" target="_blank" rel="noopener noreferrer">GitHub Pages</a>. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="https://cdn.jsdelivr.net/npm/@popperjs/core@2.11.2/dist/umd/popper.min.js" integrity="sha256-l/1pMF/+J4TThfgARS6KwWrk/egwuVvhRzfLAMQ6Ds4=" crossorigin="anonymous"></script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/js/bootstrap.min.js" integrity="sha256-SyTu6CwrfOhaznYZPoolVw2rxoY7lKYKQvqbtqN93HI=" crossorigin="anonymous"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@4/imagesloaded.pkgd.min.js"></script> <script defer src="/assets/js/masonry.js" type="text/javascript"></script> <script src="https://cdn.jsdelivr.net/npm/medium-zoom@1.0.6/dist/medium-zoom.min.js" integrity="sha256-EdPgYcPk/IIrw7FYeuJQexva49pVRZNmt3LculEr7zM=" crossorigin="anonymous"></script> <script src="/assets/js/zoom.js"></script> <script src="/assets/js/common.js"></script> <script type="text/javascript">window.MathJax={tex:{tags:"ams"}};</script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js"></script> <script defer src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> </body> </html>